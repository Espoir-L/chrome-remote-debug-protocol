/// <reference path="../typings/index.d.ts" />

import * as fs from 'fs'
import * as path from 'path'
import {IProtocol, Protocol} from './protocol'
// Rather than reading json as JSON.parse, we import a typed object
import {protocol as jsProtocol} from './protocolDef/js_protocol'
import {protocol as browserProtocol} from './protocolDef/browser_protocol'

// This is used to hold adapter and client interface definitions
interface ClientAdapterDef {
    name: string
    client: FunctionType
    adapter: FunctionType
}

interface FunctionType extends Protocol.Type {
    accepts?: FunctionType[]    
    returns?: FunctionType
}

const destFilePath = `${__dirname}/../../src/crdi.ts`
const moduleName = path.basename(destFilePath, ".ts")
const protocolDomains = jsProtocol.domains.concat(browserProtocol.domains)

let numIndents = 0
let emitStr = ""

const emit = (str: string) => {
    emitStr += str
}

const emitIndent = () => {
    for (let i = 0; i < numIndents; ++i) {
        emitStr += "    " // 4 spaced indents
    }
}

const emitLine = (str = "") => {
    emitIndent()
    emit(`${str}\n`)
}

const emitOpenBlock = (str: string, openChar = ' {') => {
    emitLine(`${str}${openChar}`)
    numIndents++
}

const emitCloseBlock = (closeChar = '}') => {
    numIndents--
    emitLine(closeChar)
}

const emitHeaderComments = () => {
    emitLine("/******************************************")
    emitLine(" * Auto-generated by protocolJsonToCrdi")
    emitLine(" ******************************************/")
    emitLine()
}

const emitModule = (moduleName:string, domains: Protocol.Domain[]) => {
    moduleName = toTitleCase(moduleName)
    emitHeaderComments()
    emitOpenBlock(`export module ${moduleName}`)
    emitGlobalTypeDefs()
    emitInterface(`${moduleName}Client`, domains.map(d => getDomainDef(d.domain, 'Client')))
    emitInterface(`${moduleName}Adapter`, domains.map(d => getDomainDef(d.domain, 'Adapter')))
    domains.forEach(emitDomain)
    emitCloseBlock()
    emitLine()
    emitLine(`export default ${moduleName};`)
}

const emitGlobalTypeDefs = () => {
    emitLine()
    emitLine(`export type integer = number`)
    emitLine(`export type PromiseOrNot<T> = T | Promise<T>;`)
}

const emitDomain = (domain: Protocol.Domain) => {
    const domainName = toTitleCase(domain.domain)
    emitLine()
    emitDescription(domain.description)
    emitOpenBlock(`export module ${domainName}`)
    domain.types ? domain.types.forEach(emitType) : null
    const commandDefs = domain.commands ? domain.commands.map(c => emitCommand(c, domainName)) : []
    const eventDefs = domain.events ? domain.events.map(e => emitEvent(e, domainName)) : []
    const functionDefs = commandDefs.concat(eventDefs)
    emitNames(commandDefs, "CommandNames")
    emitNames(eventDefs, "EventNames")
    emitCloseBlock()
    emitInterface(`${domainName}Client`, functionDefs.map(s => s.client))
    emitInterface(`${domainName}Adapter`, functionDefs.map(s => s.adapter))
}

const getDomainDef = (domainName: string, $ref:string ) => {
    return {name: domainName, $ref: `${domainName}${$ref}`}
}

const formatDescription = (description: string) => `/** ${description.replace(/<code>(.*)<\/code>/g, "'$1'")} */`

const emitDescription = (description: string) => {
    description ? emitLine(formatDescription(description)) : null
}

const getPropertyDef = (prop: Protocol.Type) => `${prop.name}${prop.optional ? '?' : ''}: ${getPropertyType(prop)}`

const getPropertyType = (prop: Protocol.Type): string  => {
    if (prop.$ref) return prop.$ref
    else if (prop.type == 'array') return `${getPropertyType(prop.items)}[]`
    else if (prop.type == 'object') return `any`
    else if (prop.type == 'function') return `(${(<FunctionType>prop).accepts.map(getPropertyDef).join(', ')}) => ${(<FunctionType>prop).returns || 'void'}`
    else if (prop.type == 'string' && prop.enum) return prop.enum.map(v => `'${v}'`).join(' | ')
    return prop.type
}

const emitProperty = (prop: Protocol.Type) => {
    emitDescription(prop.description)
    emitLine(`${getPropertyDef(prop)};`)
}

const emitInterface = (interfaceName: string, props: Protocol.Type[], emitNewLine = true): string => {
    emitNewLine ? emitLine() : null
    emitOpenBlock(`export interface ${interfaceName}`)
    props ? props.forEach(emitProperty) : emitLine('[key: string]: string;')
    emitCloseBlock()
    return interfaceName
}

const emitType = (type: Protocol.Type) => {
    emitLine()
    emitDescription(type.description)

    if (type.type === "object") {
        emitInterface(type.id, type.properties, false)
    } else {
        emitLine(`export type ${type.id} = ${getPropertyType(type)};`)
    }
}

const toTitleCase = (str: string) => str[0].toUpperCase() + str.substr(1)

const emitCommand = (command: Protocol.Command, domain: string): ClientAdapterDef => {
    const titleCase = toTitleCase(command.name)
    const requestType = command.parameters ? `${domain}.${emitInterface(`${titleCase}Request`, command.parameters)}` : null
    const responseType = command.returns ? `${domain}.${emitInterface(`${titleCase}Response`, command.returns)}` : null
    const requestArgDef = requestType ? [{name: 'request', $ref: requestType}] : []
    const clientDef: FunctionType = {
        type: 'function',
        description: command.description,
        name: command.name,
        accepts: requestArgDef,
        returns: `Promise<${responseType || '{}'}>`
    }

    const commandDef: ClientAdapterDef = {
        name: command.name,
        client: clientDef,
        adapter: Object.assign({}, clientDef, {
            name: `on${titleCase}`,
            accepts: [{
                name: "handler",
                type: "function",
                accepts: requestArgDef,
                returns: `PromiseOrNot<${responseType || '{}'}>`
            }],
            returns: null
        })
    }

    return commandDef
}

const emitEvent = (event: Protocol.Event, domain: string): ClientAdapterDef => {
    const titleCase = toTitleCase(event.name)
    const eventType = event.parameters ? `${domain}.${emitInterface(`${titleCase}Event`, event.parameters)}` : ''
    const eventArgDef = eventType ? [{name: 'event', $ref: eventType}] : []
    const clientDef: FunctionType = {
        type: 'function',
        description: event.description,
        name: `on${titleCase}`,
        accepts: [{
            name: "handler",
            type: "function",
            accepts: eventArgDef
        }],
    }
    
    const eventDef: ClientAdapterDef = {
        name: event.name,
        client: clientDef,
        adapter: Object.assign({}, clientDef, {
            name: `fire${titleCase}`,
            accepts: eventArgDef
        })
    }

    return eventDef
}

const emitNames = (names: ClientAdapterDef[], arrayName: string) => {
    emitLine()
    emitOpenBlock(`export const ${arrayName}: string[] = `, '[')
    names.forEach(s => emitLine(`'${s.name}',`))
    emitCloseBlock(']')
}

/// Main
emitModule(moduleName, protocolDomains)
fs.writeFileSync(destFilePath, emitStr, 'utf-8')
