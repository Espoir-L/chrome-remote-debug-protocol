const fs = require('fs')
const path = require('path')

const destFilePath = `${__dirname}/../src/crdpApi.ts`
const moduleName = path.basename(destFilePath, path.extname(destFilePath))
const jsProtocol = JSON.parse(fs.readFileSync(`${__dirname}/js_protocol.json`))
const browserProtocol = JSON.parse(fs.readFileSync(`${__dirname}/browser_protocol.json`))
const protocolDomains = jsProtocol.domains.concat(browserProtocol.domains)

let numIndents = 0
let emitStr = ""

const emit = (str) => {
    emitStr += str
}

const emitIndent = () => {
    for (let i = 0; i < numIndents; ++i) {
        emitStr += "    " // 4 spaced indents
    }
}

const emitLine = (str = "") => {
    emitIndent()
    emit(str + "\n")
}

const emitOpenBlock = (str) => {
    emitLine(str + " {")
    numIndents++
}

const emitCloseBlock = () => {
    numIndents--
    emitLine("}")
}

const emitHeaderComments = () => {
    emitLine("/**************************************")
    emitLine(" * Auto-generated by protocolJsonToApi")
    emitLine(" **************************************/")
    emitLine()
}

const emitModule = (moduleName, domains) => {
    emitHeaderComments()
    emitOpenBlock(`declare module '${moduleName}'`)
    emitGlobalTypedefs()
    domains.forEach(emitDomain)
    emitCloseBlock()
}

const emitDomain = (domain) => {
    emitDescription(domain.description)
    emitOpenBlock(`namespace ${domain.domain}`)
    domain.types ? domain.types.forEach(emitType) : null
    domain.commands ? domain.commands.forEach(emitCommand) : null
    domain.events ? domain.events.forEach(emitEvent) : null
    emitCloseBlock()
}

const emitGlobalTypedefs = () => {
    emitLine()
    emitLine(`type integer = number;`)
    emitLine(`type object = any;`)
}

const emitDescription = (description) => {
    emitLine()
    description ? emitLine(`/** ${description} */`) : null
}

const getPropertyStr = (prop) => {
    let propStr = `${prop.name}${prop.optional ? '?' : ''}: `

    if (prop.$ref) propStr += prop.$ref
    else if (prop.type == 'array') propStr += `${prop.items.$ref || prop.items.type}[]`
    else propStr += prop.type

    return propStr;
}

const emitTypeProperty = (prop) => {
    emitDescription(prop.description)
    emitLine(getPropertyStr(prop) + ";")
}

const emitType = (type) => {
    emitDescription(type.description)

    if (type.type === "object") {
        emitOpenBlock(`interface ${type.id}`)
        type.properties ? type.properties.forEach(emitTypeProperty) : emitLine('[key: string]: string;')
        emitCloseBlock()
    } else if (type.type === "array") {
        emitLine(`type ${type.id} = ${type.items.type || type.items.$ref}[];`)
    } else {
        emitLine(`type ${type.id} = ${type.type};`)
    }
}

const emitCommand = (command) => {
    emitLine()    
    if (command.description || command.parameters) {
        emitLine(`/**`)
        command.description ? emitLine(` * ${command.description}`) : null
        command.parameters ? command.parameters.forEach(p => emitLine(` * @param ${p.name} - ${p.description || ''}`)) : null
        emitLine(` */`)
    }

    const params = command.parameters
    const parametersStr = params ? params.map(p => getPropertyStr(p)).join(", ") : ''
    emitLine(`function ${command.name}(${parametersStr});`)
}

const emitEvent = (event) => {
    // Add on prefix for events
    const funcName = `on${event.name[0].toUpperCase()}${event.name.substr(1)}`
    emitLine()    
    if (event.description || event.parameters) {
        emitLine(`/**`)
        event.description ? emitLine(` * ${event.description}`) : null
        event.parameters ? event.parameters.forEach(p => emitLine(` * @param ${p.name} - ${p.description || ''}`)) : null
        emitLine(` */`)
    }

    const params = event.parameters
    const parametersStr = params ? params.map(p => getPropertyStr(p)).join(", ") : ''
    emitLine(`function ${funcName}(handler: (${parametersStr}) => void);`)}

emitModule(moduleName, protocolDomains)
fs.writeFileSync(destFilePath, emitStr, 'utf-8')
