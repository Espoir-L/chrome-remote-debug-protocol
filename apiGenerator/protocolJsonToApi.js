const fs = require('fs')
const path = require('path')

const destFilePath = `${__dirname}/../src/crdi.ts`
const moduleName = path.basename(destFilePath, ".ts")
const jsProtocol = JSON.parse(fs.readFileSync(`${__dirname}/js_protocol.json`))
const browserProtocol = JSON.parse(fs.readFileSync(`${__dirname}/browser_protocol.json`))
const protocolDomains = jsProtocol.domains.concat(browserProtocol.domains)

let numIndents = 0
let emitStr = ""

const emit = (str) => {
    emitStr += str
}

const emitIndent = () => {
    for (let i = 0; i < numIndents; ++i) {
        emitStr += "    " // 4 spaced indents
    }
}

const emitLine = (str = "") => {
    emitIndent()
    emit(`${str}\n`)
}

const emitOpenBlock = (str, openChar = ' {') => {
    emitLine(`${str}${openChar}`)
    numIndents++
}

const emitCloseBlock = (closeChar = '}') => {
    numIndents--
    emitLine(closeChar)
}

const emitHeaderComments = () => {
    emitLine("/**************************************")
    emitLine(" * Auto-generated by protocolJsonToApi")
    emitLine(" **************************************/")
    emitLine()
}

const emitModule = (moduleName, domains) => {
    moduleName = toTitleCase(moduleName)
    emitHeaderComments()
    emitOpenBlock(`export module ${moduleName}`)
    emitGlobalTypeDefs()
    emitInterface(`${moduleName}Client`, domains.map(d => getDomainDef(d.domain, 'Client')))
    emitInterface(`${moduleName}Adapter`, domains.map(d => getDomainDef(d.domain, 'Adapter')))
    domains.forEach(emitDomain)
    emitCloseBlock()
    emitLine()
    emitLine(`export default ${moduleName};`)
}

const emitGlobalTypeDefs = () => {
    emitLine()
    emitLine(`export type integer = number`)
    emitLine(`export type PromiseOrNot<T> = T | Promise<T>;`)
}

const emitDomain = (domain) => {
    const domainName = toTitleCase(domain.domain)
    emitLine()
    emitDescription(domain.description)
    emitOpenBlock(`export module ${domainName}`)
    domain.types ? domain.types.forEach(emitType) : null
    const commandDefs = domain.commands ? domain.commands.map(c => emitCommand(c, domainName)) : []
    const eventDefs = domain.events ? domain.events.map(e => emitEvent(e, domainName)) : []
    const functionDefs = commandDefs.concat(eventDefs)
    emitNames(commandDefs, "CommandNames")
    emitNames(eventDefs, "EventNames")
    emitCloseBlock()
    emitInterface(`${domainName}Client`, functionDefs.map(s => s.client))
    emitInterface(`${domainName}Adapter`, functionDefs.map(s => s.adapter))
}

getDomainDef = (domainName, type) => {
    return {name: domainName, $ref: `${domainName}${type}`}
}

const formatDescription = (description) => `/** ${description.replace(/<code>(.*)<\/code>/g, "'$1'")} */`

const emitDescription = (description) => {
    description ? emitLine(formatDescription(description)) : null
}

const getPropertyDef = (prop) => `${prop.name}${prop.optional ? '?' : ''}: ${getPropertyType(prop)}`

const getPropertyType = (prop)  => {
    if (prop.$ref) return prop.$ref
    else if (prop.type == 'array') return `${getPropertyType(prop.items)}[]`
    else if (prop.type == 'object') return `any`
    else if (prop.type == 'function') return `(${prop.accepts.map(getPropertyDef).join(', ')}) => ${prop.returns || 'void'}`
    else if (prop.type == 'string' && prop.enum) return prop.enum.map(v => `'${v}'`).join(' | ')
    return prop.type
}

const emitProperty = (prop) => {
    emitDescription(prop.description)
    emitLine(`${getPropertyDef(prop)};`)
}

const emitInterface = (interfaceName, props, emitNewLine = true) => {
    emitNewLine ? emitLine() : null
    emitOpenBlock(`export interface ${interfaceName}`)
    props ? props.forEach(emitProperty) : emitLine('[key: string]: string;')
    emitCloseBlock()
    return interfaceName
}

const emitType = (type) => {
    emitLine()
    emitDescription(type.description)

    if (type.type === "object") {
        emitInterface(type.id, type.properties, false)
    } else {
        emitLine(`export type ${type.id} = ${getPropertyType(type)};`)
    }
}

const toTitleCase = (str) => str[0].toUpperCase() + str.substr(1)

const emitCommand = (command, domain) => {
    const titleCase = toTitleCase(command.name)
    const requestType = command.parameters ? `${domain}.${emitInterface(`${titleCase}Request`, command.parameters)}` : null
    const responseType = command.returns ? `${domain}.${emitInterface(`${titleCase}Response`, command.returns)}` : null
    const requestArgDef = requestType ? [{name: 'request', $ref: requestType}] : []
    const clientDef = {
        type: 'function',
        description: command.description,
        name: command.name,
        accepts: requestArgDef,
        returns: `Promise<${responseType || '{}'}>`
    }

    const commandDef = {
        name: command.name,
        client: clientDef,
        adapter: Object.assign({}, clientDef, {
            name: `on${titleCase}`,
            accepts: [{
                name: "handler",
                type: "function",
                accepts: requestArgDef,
                returns: `PromiseOrNot<${responseType || '{}'}>`
            }],
            returns: null
        })
    }

    return commandDef
}

const emitEvent = (event, domain) => {
    const titleCase = toTitleCase(event.name)
    const eventType = event.parameters ? `${domain}.${emitInterface(`${titleCase}Event`, event.parameters)}` : ''
    const eventArgDef = eventType ? [{name: 'event', $ref: eventType}] : []
    const clientDef = {
        type: 'function',
        description: event.description,
        name: `on${titleCase}`,
        accepts: [{
            name: "handler",
            type: "function",
            accepts: eventArgDef
        }],
    }
    
    const eventDef = {
        name: event.name,
        client: clientDef,
        adapter: Object.assign({}, clientDef, {
            name: `fire${titleCase}`,
            accepts: eventArgDef
        })
    }

    return eventDef
}

const emitSignature = ({description, signature}) => {
    emitDescription(description)
    emitLine(signature)
}

const emitNames = (signatures, arrayName) => {
    emitLine()
    emitOpenBlock(`export const ${arrayName} = `, '[')
    signatures.forEach(s => emitLine(`'${s.name}',`))
    emitCloseBlock(']')
}

emitModule(moduleName, protocolDomains)
fs.writeFileSync(destFilePath, emitStr, 'utf-8')
