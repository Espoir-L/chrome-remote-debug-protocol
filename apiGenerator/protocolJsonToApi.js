const fs = require('fs')
const path = require('path')

const destFilePath = `${__dirname}/../src/crdpClient.d.ts`
const moduleName = path.basename(destFilePath, ".d.ts")
const jsProtocol = JSON.parse(fs.readFileSync(`${__dirname}/js_protocol.json`))
const browserProtocol = JSON.parse(fs.readFileSync(`${__dirname}/browser_protocol.json`))
const protocolDomains = jsProtocol.domains.concat(browserProtocol.domains)

let numIndents = 0
let emitStr = ""

const emit = (str) => {
    emitStr += str
}

const emitIndent = () => {
    for (let i = 0; i < numIndents; ++i) {
        emitStr += "    " // 4 spaced indents
    }
}

const emitLine = (str = "") => {
    emitIndent()
    emit(`${str}\n`)
}

const emitOpenBlock = (str) => {
    emitLine(`${str}{`)
    numIndents++
}

const emitCloseBlock = () => {
    numIndents--
    emitLine(`}`)
}

const emitHeaderComments = () => {
    emitLine("/**************************************")
    emitLine(" * Auto-generated by protocolJsonToApi")
    emitLine(" **************************************/")
    emitLine()
}

const emitModule = (moduleName, domains) => {
    emitHeaderComments()
    emitOpenBlock(`declare module '${moduleName}'`)
    domains.forEach(emitDomain)
    emitCloseBlock()
}

const emitDomain = (domain) => {
    const domainName = toTitleCase(domain.domain)
    emitLine()    
    emitDescription(domain.description)
    emitOpenBlock(`module ${domainName}`)
    domain.types ? domain.types.forEach(emitType) : null
    const commandSignatures = domain.commands ? domain.commands.map(c => emitCommand(c, domainName)) : []
    const eventSignatures = domain.events ? domain.events.map(e => emitEvent(e, domainName)) : []
    emitCloseBlock()
    emitLine()
    emitOpenBlock(`interface I${domainName}`)
    commandSignatures.forEach(emitSignature)   
    eventSignatures.forEach(emitSignature)   
    emitCloseBlock()
}

const formatDescription = (description) => `/** ${description.replace(/<code>(.*)<\/code>/g, "'$1'")} */`

const emitDescription = (description) => {
    description ? emitLine(formatDescription(description)) : null
}

const getPropertyType = (prop)  => { 
    if (prop.$ref) return prop.$ref
    else if (prop.type == 'array') return `${getPropertyType(prop.items)}[]`
    else if (prop.type == 'integer') return `number`
    else if (prop.type == 'object') return `any`
    else if (prop.type == 'string' && prop.enum) return prop.enum.map(v => `'${v}'`).join(' | ')

    return prop.type
}

const emitProperty = (prop) => {
    emitDescription(prop.description)
    emitLine(`${prop.name}${prop.optional ? '?' : ''}: ${getPropertyType(prop)};`)
}

const emitInterface = (interfaceName, props, emitNewLine = true) => {
    emitNewLine ? emitLine() : null
    emitOpenBlock(`interface ${interfaceName}`)
    props ? props.forEach(emitProperty) : emitLine('[key: string]: string;')
    emitCloseBlock()
    return interfaceName
}

const emitType = (type) => {
    emitLine()
    emitDescription(type.description)

    if (type.type === "object") {
        emitInterface(type.id, type.properties, false)
    } else {
        emitLine(`type ${type.id} = ${getPropertyType(type)};`)
    }
}

const toTitleCase = (str) => str[0].toUpperCase() + str.substr(1)

const emitCommand = (command, domain) => {
    const titleCase = toTitleCase(command.name)
    const requestParams = command.parameters ? `params: ${domain}.${emitInterface(`${titleCase}Request`, command.parameters)}` : ''
    const responseType = `Promise<${command.returns ? `${domain}.${emitInterface(`${titleCase}Response`, command.returns)}` : 'void' }>`
    return { 
        description: command.description, 
        signature: `${command.name}(${requestParams}): ${responseType};`
    }
}

const emitEvent = (event, domain) => {
    const titleCase = toTitleCase(event.name)
    const eventParams = event.parameters ? `event: ${domain}.${emitInterface(`${titleCase}Event`, event.parameters)}` : ''
    return { 
        description: event.description, 
        signature: `on${titleCase}(handler: (${eventParams}) => void);`
    }
}

const emitSignature = ({description, signature}) => {
    emitDescription(description)
    emitLine(signature)
}

emitModule(moduleName, protocolDomains)
fs.writeFileSync(destFilePath, emitStr, 'utf-8')
